<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Markdown ZIP Viewer</title>
    <!-- Required external libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.2/marked.min.js"></script>
    <!-- Annotation styles -->
    <link rel="stylesheet" href="annotation-styles.css" />
    <link rel="stylesheet" href="styles/reset.css" />
    <link rel="stylesheet" href="styles/themes.css" />
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <!-- Mobile Header -->
    <div class="mobile-header">
      <div class="mobile-header-left">
        <button class="mobile-menu-toggle" onclick="toggleMenu()">‚ò∞</button>
        <div class="mobile-header-title">MD Viewer</div>
      </div>
      <div class="mobile-header-right">
        <!-- Annotation toggle will go here -->
      </div>
    </div>

    <!-- Original Menu Toggle Button (now hidden via CSS on mobile) -->
    <button class="menu-toggle" onclick="toggleMenu()">‚ò∞</button>

    <div class="container">
      <div class="sidebar" id="sidebar">
        <div class="collection-controls">
          <div class="collection-heading">
            <h4>
              Your Collections
              <span class="collections-toggle" id="collections-toggle"></span>
            </h4>
            <label class="file-input-button">
              Import ZIP
              <input type="file" id="zip-file-input" accept=".zip" />
            </label>
          </div>

          <div class="collection-list-container" id="collection-list-container">
            <ul id="collection-list">
              <li class="empty">No collections yet</li>
            </ul>
          </div>
        </div>
        <div class="nav-links">
          <a href="AnnotationPage.html" class="nav-link">
            <i>üìù</i> View All Annotations
          </a>
        </div>

        <!-- Filter Controls - New Section -->
        <div class="filter-controls">
          <!-- View Toggle Buttons -->
          <div class="view-toggle">
            <button id="view-articles-btn" class="view-toggle-btn active">
              Articles
            </button>
            <button id="view-annotations-btn" class="view-toggle-btn">
              Annotations
            </button>
          </div>

          <!-- Sort Pills -->
          <div class="sort-pills">
            <button data-sort="recency" class="sort-pill active">Recent</button>
            <button data-sort="alphabet" class="sort-pill">A-Z</button>
            <button data-sort="unread_first" class="sort-pill">Unread</button>
            <button
              data-sort="annotations"
              class="sort-pill"
              id="annotations-sort-pill"
            >
              Most Annotated
            </button>
          </div>

          <!-- Tag Filter -->
          <div class="tag-filter">
            <div class="tag-dropdown-wrapper">
              <label for="tag-dropdown-btn">Filter by tag:</label>
              <div class="tag-dropdown-container">
                <button id="tag-dropdown-btn">
                  <span id="tag-dropdown-text">Select a tag</span>
                  <span class="dropdown-arrow">‚ñº</span>
                </button>
                <div
                  id="tag-dropdown-list"
                  class="tag-dropdown-list"
                  style="display: none"
                >
                  <!-- Tags will be populated here by JS -->
                  <div class="tag-option" data-tag="">All Tags</div>
                  <!-- Other tags will be added dynamically -->
                </div>
              </div>
              <button
                id="clear-tags-btn"
                class="clear-tags-btn"
                style="display: none"
              >
                Clear
              </button>
            </div>

            <!-- Selected Tags Area -->
            <div
              id="selected-tags-container"
              class="selected-tags-container"
            ></div>
          </div>
        </div>

        <!-- Original File Controls - Keep for compatibility -->
        <div class="file-controls">
          <label for="sort-order" style="width: 100%">Sort by:</label>
          <select id="sort-order" style="padding: 5px; width: 100%">
            <option value="alphabet">Alphabetical</option>
            <option value="unread_first">Unread First</option>
            <option value="read_first">Read First</option>
            <option value="read_date">Recently Read</option>
          </select>

          <div id="status-message"></div>
        </div>

        <div class="file-list" id="file-list">
          <div class="empty-state">
            <p>No ZIP files imported</p>
            <p>Use the Import ZIP button above to get started</p>
          </div>
        </div>
      </div>
      <div class="main-content" id="markdown-content">
        <div class="empty-state">
          <p>No markdown file selected</p>
          <p>Import a ZIP file and select a markdown file to view</p>
        </div>
      </div>
      <!-- Annotation panel will be inserted here by the AnnotationSystem -->
    </div>

    <!-- Add Overlay Element -->
    <div class="overlay" id="overlay" onclick="toggleMenu()"></div>

    <script type="module">
      import {ZipFileManager} from "./ZipFileManager.js";
      import {renderMarkdownToElement} from "./MarkdownRendering.js";
      import {AnnotationSystem} from "./MarkdownAnnotation.js";
      import {ArticleNavigationHelper} from "./ArticleNavigation.js";
      import {setupSwipeNavigation} from "./SwipeNavigation.js";
      import {
        refreshCollections,
        selectCollection,
      } from "./CollectionsManager.js";

      // Collection management functions are now imported from CollectionsManager.js

      // --- Toggle Menu Function ---
      window.toggleMenu = function () {
        document.getElementById("sidebar").classList.toggle("open");
        document.getElementById("overlay").classList.toggle("active");
      };
      // --- End Toggle Menu Function ---

      // --- Toggle Collections Function ---
      document
        .getElementById("collections-toggle")
        .addEventListener("click", function () {
          this.classList.toggle("collapsed");
          document
            .getElementById("collection-list-container")
            .classList.toggle("collapsed");

          // Save preference in localStorage
          const isCollapsed = this.classList.contains("collapsed");
          localStorage.setItem("collections_collapsed", isCollapsed);
        });

      // Check saved preference
      const savedCollapsedState = localStorage.getItem("collections_collapsed");
      if (savedCollapsedState === "true") {
        document
          .getElementById("collections-toggle")
          .classList.add("collapsed");
        document
          .getElementById("collection-list-container")
          .classList.add("collapsed");
      }
      // --- End Toggle Collections Function ---

      // Initialize the ZipFileManager
      const zipManager = new ZipFileManager({
        statusCallback: (type, message) => {
          const statusElement = document.getElementById("status-message");
          statusElement.innerHTML = `<div class="status ${type}">${message}</div>`;

          // Clear status after a few seconds
          setTimeout(() => {
            statusElement.innerHTML = "";
          }, 5000);
        },
      });

      // Initialize variables
      let currentZipId = null;
      let currentZipFiles = [];
      let selectedFile = null;
      let articleNavigator = null;

      // Tag filtering state
      let allUniqueTags = [];
      let selectedTags = [];
      let viewMode = "articles"; // 'articles' or 'annotations'

      // DOM elements
      const zipFileInput = document.getElementById("zip-file-input");
      const fileListElement = document.getElementById("file-list");
      const markdownContentElement =
        document.getElementById("markdown-content");
      const sortOrderSelect = document.getElementById("sort-order");

      // New UI elements
      const viewArticlesBtn = document.getElementById("view-articles-btn");
      const viewAnnotationsBtn = document.getElementById(
        "view-annotations-btn"
      );
      const sortPills = document.querySelectorAll(".sort-pill");
      const tagDropdownBtn = document.getElementById("tag-dropdown-btn");
      const tagDropdownText = document.getElementById("tag-dropdown-text");
      const tagDropdownList = document.getElementById("tag-dropdown-list");
      const clearTagsBtn = document.getElementById("clear-tags-btn");
      const selectedTagsContainer = document.getElementById(
        "selected-tags-container"
      );
      const annotationsSortPill = document.getElementById(
        "annotations-sort-pill"
      );

      // Event handlers
      zipFileInput.addEventListener("change", handleZipFileUpload);

      // Add event listener for sort order changes
      sortOrderSelect.addEventListener("change", handleSortOrderChange);

      // Event listeners for tag filtering UI
      viewArticlesBtn.addEventListener("click", () => setViewMode("articles"));
      viewAnnotationsBtn.addEventListener("click", () =>
        setViewMode("annotations")
      );

      // Sort pills click handlers
      sortPills.forEach((pill) => {
        pill.addEventListener("click", () => {
          const sortValue = pill.getAttribute("data-sort");
          setSortMethod(sortValue);
        });
      });

      // Tag dropdown toggle
      tagDropdownBtn.addEventListener("click", () => {
        const isOpen = tagDropdownList.style.display === "block";
        tagDropdownList.style.display = isOpen ? "none" : "block";

        // Toggle dropdown arrow direction
        const dropdownArrow = tagDropdownBtn.querySelector(".dropdown-arrow");
        if (dropdownArrow) {
          dropdownArrow.classList.toggle("open", !isOpen);
        }
      });

      // Close dropdown when clicking outside
      document.addEventListener("click", (e) => {
        if (
          !tagDropdownBtn.contains(e.target) &&
          !tagDropdownList.contains(e.target)
        ) {
          tagDropdownList.style.display = "none";

          // Reset arrow direction
          const dropdownArrow = tagDropdownBtn.querySelector(".dropdown-arrow");
          if (dropdownArrow) {
            dropdownArrow.classList.remove("open");
          }
        }
      });

      // Clear tags button
      clearTagsBtn.addEventListener("click", clearSelectedTags);

      // Set view mode between articles and annotations
      function setViewMode(mode) {
        viewMode = mode;

        // Update UI
        viewArticlesBtn.classList.toggle("active", mode === "articles");
        viewAnnotationsBtn.classList.toggle("active", mode === "annotations");

        // Show/hide annotations sort pill based on view mode
        annotationsSortPill.style.display =
          mode === "annotations" ? "inline-block" : "none";

        // Refresh the file list
        if (currentZipId !== null) {
          zipManager
            .getZipFileById(currentZipId)
            .then((zipData) => {
              displayZipContents(zipData);
            })
            .catch((error) => {
              console.error("Error refreshing ZIP contents:", error);
            });
        }
      }

      // Set sort method
      function setSortMethod(method) {
        // Update sort-order select to match for backwards compatibility
        if (method === "recency") {
          sortOrderSelect.value = "read_date";
        } else if (method === "alphabet") {
          sortOrderSelect.value = "alphabet";
        } else if (method === "unread_first") {
          sortOrderSelect.value = "unread_first";
        } else if (method === "annotations") {
          // This is a new sort option not in the original select
          sortOrderSelect.value = "read_date"; // fallback to something reasonable
        }

        // Update UI
        sortPills.forEach((pill) => {
          pill.classList.toggle(
            "active",
            pill.getAttribute("data-sort") === method
          );
        });

        // Save preference and refresh display
        localStorage.setItem("md_file_sort_order", sortOrderSelect.value);

        // Refresh the file list
        if (currentZipId !== null) {
          zipManager
            .getZipFileById(currentZipId)
            .then((zipData) => {
              displayZipContents(zipData);
            })
            .catch((error) => {
              console.error("Error refreshing ZIP contents:", error);
            });
        }
      }

      // Toggle or select a tag
      function handleTagSelection(tag, toggle = false) {
        if (toggle) {
          // Toggle the tag (add if not present, remove if present)
          if (selectedTags.includes(tag)) {
            selectedTags = selectedTags.filter((t) => t !== tag);
          } else {
            selectedTags.push(tag);
          }
        } else {
          // Set to just this one tag
          selectedTags = tag ? [tag] : [];
        }

        // Update UI
        updateTagUI();

        // Hide dropdown after selection
        tagDropdownList.style.display = "none";
        const dropdownArrow = tagDropdownBtn.querySelector(".dropdown-arrow");
        if (dropdownArrow) {
          dropdownArrow.classList.remove("open");
        }

        // Refresh the file list
        if (currentZipId !== null) {
          zipManager
            .getZipFileById(currentZipId)
            .then((zipData) => {
              displayZipContents(zipData);
            })
            .catch((error) => {
              console.error("Error refreshing ZIP contents:", error);
            });
        }
      }

      // Clear all selected tags
      function clearSelectedTags() {
        selectedTags = [];
        updateTagUI();

        // Refresh the file list
        if (currentZipId !== null) {
          zipManager
            .getZipFileById(currentZipId)
            .then((zipData) => {
              displayZipContents(zipData);
            })
            .catch((error) => {
              console.error("Error refreshing ZIP contents:", error);
            });
        }
      }

      // Update tag UI (selected tags, dropdown text, clear button visibility)
      function updateTagUI() {
        // Update dropdown text
        tagDropdownText.textContent =
          selectedTags.length > 0
            ? `${selectedTags.length} tag${
                selectedTags.length !== 1 ? "s" : ""
              } selected`
            : "Select a tag";

        // Show/hide clear button
        clearTagsBtn.style.display = selectedTags.length > 0 ? "block" : "none";

        // Render selected tags as pills
        selectedTagsContainer.innerHTML = "";
        selectedTags.forEach((tag) => {
          const tagPill = document.createElement("span");
          tagPill.className = "tag-pill";

          // Tag text
          const tagText = document.createTextNode(tag);
          tagPill.appendChild(tagText);

          // Remove button
          const removeBtn = document.createElement("button");
          removeBtn.className = "remove-tag";
          removeBtn.textContent = "√ó";
          removeBtn.addEventListener("click", () =>
            handleTagSelection(tag, true)
          );
          tagPill.appendChild(removeBtn);

          selectedTagsContainer.appendChild(tagPill);
        });
      }

      // Extract all unique tags from a list of files
      function extractUniqueTags(files) {
        // Start with ZIP name as a tag if available
        const zipNameTag =
          currentZipId && zipManager.getZipNameById
            ? zipManager.getZipNameById(currentZipId)
            : null;

        const allTags = new Set();

        // Add ZIP name as a tag if it exists and is valid
        if (
          zipNameTag &&
          typeof zipNameTag === "string" &&
          zipNameTag.trim() !== ""
        ) {
          // Clean up name (remove extension, replace non-alphanumeric with dash)
          const cleanZipName = zipNameTag
            .replace(/\.zip$/i, "")
            .replace(/[^a-z0-9]/gi, "-")
            .toLowerCase();

          if (cleanZipName.trim() !== "") {
            allTags.add(cleanZipName);
          }
        }

        // Extract tags from each file
        files.forEach((file) => {
          if (file.tags && Array.isArray(file.tags)) {
            file.tags.forEach((tag) => {
              if (tag && typeof tag === "string" && tag.trim() !== "") {
                allTags.add(tag.trim());
              }
            });
          }
        });

        return [...allTags].sort();
      }

      // Handle sort order changes
      function handleSortOrderChange() {
        // Save the sort order preference
        localStorage.setItem("md_file_sort_order", sortOrderSelect.value);

        // If there's a current ZIP file loaded, re-display with new sort order
        if (currentZipId !== null) {
          zipManager
            .getZipFileById(currentZipId)
            .then((zipData) => {
              displayZipContents(zipData);
            })
            .catch((error) => {
              console.error("Error refreshing ZIP contents:", error);
            });
        }
      }

      // Handle ZIP file upload
      async function handleZipFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
          // Save the ZIP file using ZipFileManager
          currentZipId = await zipManager.saveZipFile(file);

          // Get the saved ZIP file data
          const zipData = await zipManager.getZipFileById(currentZipId);

          // Display the ZIP file contents
          displayZipContents(zipData);

          // Refresh the collections list
          await refreshCollections(
            zipManager,
            document.getElementById("collection-list"),
            currentZipId,
            document.getElementById("markdown-content"),
            displayZipContents
          );

          // Reset the file input
          zipFileInput.value = "";
        } catch (error) {
          console.error("Error uploading ZIP file:", error);
          showStatus("error", `Error: ${error.message}`);
        }
      }

      // Display ZIP contents in the file list
      function displayZipContents(zipData) {
        // Store current ZIP files for reference
        currentZipFiles = zipData.files;

        // Clear previous file list
        fileListElement.innerHTML = "";

        // Add ZIP info
        const zipInfoElement = document.createElement("div");
        zipInfoElement.className = "zip-info";
        zipInfoElement.textContent = `${zipData.name} (${zipData.fileCount} files)`;
        fileListElement.appendChild(zipInfoElement);

        // Filter for markdown files and sort them
        const mdFiles = zipData.files.filter((file) => {
          const lowerPath = file.path.toLowerCase();
          return lowerPath.endsWith(".md") || lowerPath.endsWith(".markdown");
        });

        // Extract all unique tags from the files
        allUniqueTags = extractUniqueTags(mdFiles);

        // Populate the tag dropdown
        populateTagDropdown(allUniqueTags);

        // Update the tag UI based on selected tags
        updateTagUI();

        // Get current sort order from dropdown or localStorage
        const sortOrderSelect = document.getElementById("sort-order");
        const savedSortOrder = localStorage.getItem("md_file_sort_order");

        // Set dropdown to saved sort order if available
        if (savedSortOrder) {
          sortOrderSelect.value = savedSortOrder;
        }

        // Get current selected sort order
        const sortOrder = sortOrderSelect.value;

        // Filter files based on selected tags and view mode
        let filteredFiles = mdFiles;

        // Apply tag filtering if we have selected tags
        if (selectedTags.length > 0) {
          filteredFiles = filteredFiles.filter((file) => {
            // Check if file has tags
            if (!file.tags || !Array.isArray(file.tags)) {
              return false;
            }

            // File must have ALL selected tags to be included
            return selectedTags.every((tag) => file.tags.includes(tag));
          });
        }

        // Apply view mode filtering
        if (viewMode === "annotations") {
          filteredFiles = filteredFiles.filter((file) => {
            // If we know the annotations count, use it
            if (typeof file.annotations === "number") {
              return file.annotations > 0;
            }

            // Otherwise, assume all files might have annotations for now
            return true;
          });
        }

        // Apply additional sorting for annotations if needed
        if (
          viewMode === "annotations" &&
          document.querySelector('.sort-pill[data-sort="annotations"].active')
        ) {
          // Sort by annotation count if we have that data
          filteredFiles.sort((a, b) => {
            const aCount =
              typeof a.annotations === "number" ? a.annotations : 0;
            const bCount =
              typeof b.annotations === "number" ? b.annotations : 0;
            return bCount - aCount; // Descending order
          });
        } else {
          // Apply standard sorting using ZipFileManager
          filteredFiles = zipManager.sortFilesByReadStatus(
            filteredFiles,
            sortOrder
          );
        }

        // Initialize the article navigator with filtered files
        articleNavigator = new ArticleNavigationHelper(filteredFiles);

        // --- Re-Setup Swipe Navigation with the new navigator ---
        setupSwipeNavigation(
          markdownContentElement,
          articleNavigator,
          displayMarkdownFile,
          updateSidebarSelection
        );
        // --- End Re-Setup ---

        // Create file items for each markdown file
        if (filteredFiles.length > 0) {
          filteredFiles.forEach((file) => {
            const fileItem = document.createElement("div");
            fileItem.className = "file-item md-file";

            // Add read/unread class based on file status
            if (file.isRead) {
              fileItem.classList.add("read");
            } else {
              fileItem.classList.add("unread");
            }

            // Create a container for file title
            const fileTitle = document.createElement("div");
            fileTitle.className = "file-title";
            fileTitle.textContent = file.displayName || file.path;
            fileItem.appendChild(fileTitle);

            // Display tags if available
            if (file.tags && Array.isArray(file.tags) && file.tags.length > 0) {
              const tagsContainer = document.createElement("div");
              tagsContainer.className = "file-item-tags";

              // Limit to first 3 tags to avoid clutter
              const displayTags = file.tags.slice(0, 3);
              displayTags.forEach((tag) => {
                const tagElement = document.createElement("span");
                tagElement.className = "file-item-tag";
                // Add active class if this tag is in selectedTags
                if (selectedTags.includes(tag)) {
                  tagElement.classList.add("active");
                }
                tagElement.textContent = tag;
                tagElement.addEventListener("click", (e) => {
                  e.stopPropagation(); // Don't trigger file selection
                  handleTagSelection(tag, true); // Toggle this tag
                });
                tagsContainer.appendChild(tagElement);
              });

              // Add "+" indicator if there are more tags
              if (file.tags.length > 3) {
                const moreIndicator = document.createElement("span");
                moreIndicator.className = "file-item-more-tags";
                moreIndicator.textContent = `+${file.tags.length - 3}`;
                tagsContainer.appendChild(moreIndicator);
              }

              fileItem.appendChild(tagsContainer);
            }

            // Display annotations count if in annotations mode
            if (
              viewMode === "annotations" &&
              typeof file.annotations === "number" &&
              file.annotations > 0
            ) {
              const annotCount = document.createElement("span");
              annotCount.className = "annotation-count";
              annotCount.textContent = file.annotations;
              fileItem.appendChild(annotCount);
            }

            // Store the original path for file identification
            fileItem.dataset.path = file.path;

            // Add double-click handler to toggle read status
            fileItem.addEventListener("dblclick", (event) => {
              // Prevent single-click handler from firing
              event.stopPropagation();

              // Toggle read status
              zipManager
                .toggleReadState(currentZipId, file.path)
                .then((isRead) => {
                  // Update UI to reflect new status
                  updateFileItemReadStatus(file.path, isRead);
                })
                .catch((error) => {
                  console.error("Error toggling read status:", error);
                });
            });

            fileItem.addEventListener("click", () => {
              // Remove active class from all items
              document.querySelectorAll(".file-item").forEach((item) => {
                item.classList.remove("active");
              });

              // Add active class to clicked item
              fileItem.classList.add("active");

              // Display the markdown file
              displayMarkdownFile(file);
            });

            fileListElement.appendChild(fileItem);
          });
        } else {
          // Display empty state for filtered results
          const emptyElement = document.createElement("div");
          emptyElement.className = "empty-filter-results";

          // Icon (book or pencil based on view mode)
          const icon = document.createElement("div");
          icon.className = "icon";
          icon.textContent = viewMode === "annotations" ? "üìù" : "üìö";
          emptyElement.appendChild(icon);

          // Title
          const title = document.createElement("h3");
          title.textContent =
            viewMode === "annotations"
              ? "No annotations found"
              : selectedTags.length > 0
              ? "No matching files found"
              : "No markdown files found";
          emptyElement.appendChild(title);

          // Action hint
          if (selectedTags.length > 0) {
            const action = document.createElement("p");
            action.textContent = "Try adjusting your tag filters";
            action.className = "action-hint";
            emptyElement.appendChild(action);

            // Add clear filters button
            const clearBtn = document.createElement("button");
            clearBtn.textContent = "Clear Filters";
            clearBtn.className = "clear-filters-btn";
            clearBtn.addEventListener("click", clearSelectedTags);
            emptyElement.appendChild(clearBtn);
          } else if (mdFiles.length === 0) {
            const action = document.createElement("p");
            action.textContent = "No markdown files found in this ZIP";
            action.className = "action-hint";
            emptyElement.appendChild(action);
          }

          fileListElement.appendChild(emptyElement);
        }
      }

      // Populate the tag dropdown with available tags
      function populateTagDropdown(tags) {
        // Clear existing tags, but keep the "All Tags" option
        const allTagsOption = tagDropdownList.querySelector(
          '.tag-option[data-tag=""]'
        );
        tagDropdownList.innerHTML = "";
        if (allTagsOption) {
          tagDropdownList.appendChild(allTagsOption);
        } else {
          const newAllTagsOption = document.createElement("div");
          newAllTagsOption.className = "tag-option";
          newAllTagsOption.setAttribute("data-tag", "");
          newAllTagsOption.textContent = "All Tags";
          newAllTagsOption.addEventListener("click", () =>
            handleTagSelection("")
          );
          tagDropdownList.appendChild(newAllTagsOption);
        }

        // Add tags to dropdown
        tags.forEach((tag) => {
          const tagOption = document.createElement("div");
          tagOption.className = "tag-option";
          if (selectedTags.includes(tag)) {
            tagOption.classList.add("selected");
          }
          tagOption.setAttribute("data-tag", tag);
          tagOption.textContent = tag;
          tagOption.addEventListener("click", () => handleTagSelection(tag));
          tagDropdownList.appendChild(tagOption);
        });
      }

      // Display a markdown file in the main content area
      function displayMarkdownFile(file) {
        // Add a fade-out effect before changing content
        markdownContentElement.style.opacity = "0";

        setTimeout(() => {
          selectedFile = file;

          // Clear any existing annotations
          if (AnnotationSystem.reset) {
            AnnotationSystem.reset();
          }

          // Render markdown content using the MarkdownRendering module
          renderMarkdownToElement(file.content, markdownContentElement);

          // --- Add Article Note Button ---
          const articleNoteContainer = document.createElement("div");
          articleNoteContainer.style.padding = "10px 0"; // Add some spacing
          articleNoteContainer.style.borderBottom = "1px solid #eee"; // Separator
          articleNoteContainer.style.marginBottom = "15px";

          const articleNoteButton = document.createElement("button");
          articleNoteButton.textContent = "Add Note to Article";
          articleNoteButton.style.fontSize = "0.9em"; // Slightly smaller button
          articleNoteButton.onclick = () => {
            if (AnnotationSystem.createArticleAnnotation) {
              // Ensure the method exists before calling
              AnnotationSystem.createArticleAnnotation();
            } else {
              console.warn(
                "AnnotationSystem.createArticleAnnotation is not yet implemented."
              );
              alert(
                "Functionality to add article notes is not yet fully implemented."
              );
            }
          };

          articleNoteContainer.appendChild(articleNoteButton);
          // Prepend the button container to the main content area
          markdownContentElement.prepend(articleNoteContainer);
          // --- End Add Article Note Button ---

          // Set current article in the navigator
          if (articleNavigator) {
            articleNavigator.setCurrentArticle(file.path);
          }

          // Remove any existing navigation buttons
          const existingNav = markdownContentElement.querySelector(
            ".article-navigation"
          );
          if (existingNav) {
            existingNav.remove();
          }

          // Add navigation buttons if we have an article navigator
          if (articleNavigator) {
            articleNavigator.createNavigationButtons(
              markdownContentElement,
              (article) => {
                // Update sidebar before displaying
                updateSidebarSelection(article);
                // Display the article (will include fade in)
                displayMarkdownFile(article);
              }
            );
          }

          // Initialize annotation system on the rendered content
          setTimeout(() => {
            // Pass the current ZIP ID as the file ID and the path as the file path
            AnnotationSystem.initialize(
              markdownContentElement,
              currentZipId,
              file.path
            );

            // Access annotation tags if available from the annotation system
            if (AnnotationSystem.getTagsForFile) {
              AnnotationSystem.getTagsForFile(currentZipId, file.path)
                .then((tags) => {
                  if (tags && tags.length > 0) {
                    // Ensure file has a tags array
                    if (!file.tags) {
                      file.tags = [];
                    }

                    // Add any new tags from annotations
                    tags.forEach((tag) => {
                      if (!file.tags.includes(tag)) {
                        file.tags.push(tag);
                      }
                    });

                    // If we added new tags, update the tags UI
                    if (currentZipId) {
                      // Refresh all unique tags
                      allUniqueTags = extractUniqueTags(currentZipFiles);

                      // Update tag dropdown with new tags
                      populateTagDropdown(allUniqueTags);

                      // Update displayed tags in the file list
                      const fileItem = document.querySelector(
                        `.file-item[data-path="${file.path}"]`
                      );
                      if (fileItem) {
                        updateFileItemTags(fileItem, file);
                      }
                    }
                  }
                })
                .catch((error) => {
                  console.error("Error getting annotation tags:", error);
                });
            }

            // Count annotations if that method is available
            if (AnnotationSystem.getAnnotationCount) {
              AnnotationSystem.getAnnotationCount(currentZipId, file.path)
                .then((count) => {
                  if (typeof count === "number") {
                    file.annotations = count;

                    // Update annotation count in file list if in annotations view
                    if (viewMode === "annotations") {
                      const fileItem = document.querySelector(
                        `.file-item[data-path="${file.path}"]`
                      );
                      if (fileItem) {
                        updateFileItemAnnotationCount(fileItem, file);
                      }
                    }
                  }
                })
                .catch((error) => {
                  console.error("Error getting annotation count:", error);
                });
            }

            // Fade back in AFTER rendering and annotation init
            markdownContentElement.style.opacity = "1";

            // Scroll window to top after content is rendered and visible
            window.scrollTo(0, 0);
          }, 100); // Small delay to ensure rendering is complete

          // Mark the file as read
          zipManager
            .markFileAsRead(currentZipId, file.path)
            .then(() => {
              // Update the file list item to show read status
              updateFileItemReadStatus(file.path, true);
            })
            .catch((error) => {
              console.error("Error marking file as read:", error);
            });
        }, 150); // Match fade-out time before starting content update
      }

      // Helper function to update file item tags
      function updateFileItemTags(fileItem, file) {
        // Remove existing tags container
        const existingTags = fileItem.querySelector(".file-item-tags");
        if (existingTags) {
          existingTags.remove();
        }

        // Add new tags if available
        if (file.tags && Array.isArray(file.tags) && file.tags.length > 0) {
          const tagsContainer = document.createElement("div");
          tagsContainer.className = "file-item-tags";

          // Limit to first 3 tags to avoid clutter
          const displayTags = file.tags.slice(0, 3);
          displayTags.forEach((tag) => {
            const tagElement = document.createElement("span");
            tagElement.className = "file-item-tag";
            // Add active class if this tag is in selectedTags
            if (selectedTags.includes(tag)) {
              tagElement.classList.add("active");
            }
            tagElement.textContent = tag;
            tagElement.addEventListener("click", (e) => {
              e.stopPropagation(); // Don't trigger file selection
              handleTagSelection(tag, true); // Toggle this tag
            });
            tagsContainer.appendChild(tagElement);
          });

          // Add "+" indicator if there are more tags
          if (file.tags.length > 3) {
            const moreIndicator = document.createElement("span");
            moreIndicator.className = "file-item-more-tags";
            moreIndicator.textContent = `+${file.tags.length - 3}`;
            tagsContainer.appendChild(moreIndicator);
          }

          fileItem.appendChild(tagsContainer);
        }
      }

      // Helper function to update file item annotation count
      function updateFileItemAnnotationCount(fileItem, file) {
        // Remove existing annotation count
        const existingCount = fileItem.querySelector(".annotation-count");
        if (existingCount) {
          existingCount.remove();
        }

        // Add annotation count if available
        if (
          viewMode === "annotations" &&
          typeof file.annotations === "number" &&
          file.annotations > 0
        ) {
          const annotCount = document.createElement("span");
          annotCount.className = "annotation-count";
          annotCount.textContent = file.annotations;
          fileItem.appendChild(annotCount);
        }
      }

      // Display status message
      function showStatus(type, message) {
        const statusElement = document.getElementById("status-message");
        statusElement.innerHTML = `<div class="status ${type}">${message}</div>`;

        // Clear status after a few seconds
        setTimeout(() => {
          statusElement.innerHTML = "";
        }, 5000);
      }

      // Function to handle URL parameters and open the specified file
      async function openFileFromUrlParams() {
        const params = new URLSearchParams(window.location.search);
        const fileId = params.get("file");
        const filePath = params.get("path");

        if (fileId && filePath) {
          try {
            console.log(`Opening file: ${filePath} from ZIP ID: ${fileId}`);

            // Set current ZIP ID
            currentZipId = parseInt(fileId, 10);
            if (isNaN(currentZipId)) {
              currentZipId = fileId; // Handle string IDs if needed
            }

            // Get the ZIP file data
            const zipData = await zipManager.getZipFileById(currentZipId);

            // Display the ZIP contents
            displayZipContents(zipData);

            // Find the specified file
            const targetFile = zipData.files.find(
              (file) => file.path === filePath
            );
            if (targetFile) {
              // Highlight the file in the sidebar
              const fileItem = document.querySelector(
                `.file-item[data-path="${filePath}"]`
              );
              if (fileItem) {
                fileItem.classList.add("active");
              }
              // Display the file
              displayMarkdownFile(targetFile);
              showStatus("success", `Opened file: ${filePath}`);
            } else {
              showStatus("error", `File not found: ${filePath}`);
            }
          } catch (error) {
            console.error("Error opening file from URL parameters:", error);
            showStatus("error", `Error opening file: ${error.message}`);
          }
        }
      }

      // Initialize
      (async function init() {
        try {
          // Initialize IndexedDB
          await zipManager.initIndexedDB();

          // Load saved sort order preference
          const savedSortOrder = localStorage.getItem("md_file_sort_order");
          if (savedSortOrder) {
            sortOrderSelect.value = savedSortOrder;
          }

          // Initialize tag filtering UI
          // Hide annotations sort pill initially if we're in articles view
          if (viewMode === "articles") {
            annotationsSortPill.style.display = "none";
          }

          // Set active sort pill based on current sort order
          let activeSortPill = "recency"; // default
          if (savedSortOrder === "alphabet") {
            activeSortPill = "alphabet";
          } else if (savedSortOrder === "unread_first") {
            activeSortPill = "unread_first";
          } else if (savedSortOrder === "read_date") {
            activeSortPill = "recency";
          }

          sortPills.forEach((pill) => {
            pill.classList.toggle(
              "active",
              pill.getAttribute("data-sort") === activeSortPill
            );
          });

          // Get all existing ZIP files
          const zipFiles = await zipManager.getAllZipFiles();

          // Check if there are URL parameters to open a specific file
          const hasUrlParams =
            window.location.search.includes("file=") &&
            window.location.search.includes("path=");

          if (hasUrlParams) {
            // Try to open file from URL parameters
            await openFileFromUrlParams();
          } else if (zipFiles.length > 0) {
            // If no URL parameters but there are ZIP files, display the most recent one
            const mostRecent = zipFiles[zipFiles.length - 1];
            currentZipId = mostRecent.id;
            displayZipContents(mostRecent);
          }

          // --- Conditionally open sidebar on mobile for initial load without specific file ---
          if (!hasUrlParams && window.innerWidth <= 768) {
            // Check if sidebar is not already open
            const sidebar = document.getElementById("sidebar");
            if (sidebar && !sidebar.classList.contains("open")) {
              console.log("Opening sidebar on mobile initial load.");
              toggleMenu(); // Assumes toggleMenu is globally accessible
            }
          }
          // --- End conditional sidebar opening ---

          // --- Setup Swipe Navigation (conditionally) ---
          setupSwipeNavigation(
            markdownContentElement,
            articleNavigator,
            displayMarkdownFile,
            updateSidebarSelection
          );
          // --- End Setup Swipe Navigation ---

          // Refresh the collections list
          await refreshCollections(
            zipManager,
            document.getElementById("collection-list"),
            currentZipId,
            document.getElementById("markdown-content"),
            displayZipContents
          );
        } catch (error) {
          console.error("Error during initialization:", error);
          showStatus("error", `Initialization failed: ${error.message}`);
        }
      })(); // Immediately invoke the async function

      // Update a file item's read status in the UI
      function updateFileItemReadStatus(filePath, isRead) {
        const fileItem = document.querySelector(
          `.file-item[data-path="${filePath}"]`
        );
        if (fileItem) {
          if (isRead) {
            fileItem.classList.add("read");
            fileItem.classList.remove("unread");
          } else {
            fileItem.classList.add("unread");
            fileItem.classList.remove("read");
          }
        }
      }

      // --- Helper for Sidebar Update on Swipe ---
      function updateSidebarSelection(article) {
        const fileItem = document.querySelector(
          `.file-item[data-path="${article.path}"]`
        );
        if (fileItem) {
          document.querySelectorAll(".file-item").forEach((item) => {
            item.classList.remove("active");
          });
          fileItem.classList.add("active");
          fileItem.scrollIntoView({block: "nearest"});
        }
      }
      // --- End Helper ---
    </script>
  </body>
</html>
